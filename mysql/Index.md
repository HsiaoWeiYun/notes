### Index

#### 索引原理探究
* 什麼是資料庫索引: 索引是一種單獨的、物理的對資料庫表中一列或多列的值進行排序的一種儲存結構, <br>
  是某個表中一列或多列的集合以及相對應指向物理標記這些資料頁的邏輯指針清單. <br>
  (其實解讀成圖書目錄就可以了, 如果想在圖書館藏中找到書或者特定內容, 沒有目錄的狀況下只能一本一本去翻.) <br>
  
* B Tree And B+ Tree: 相對CPU與記憶體操作, 硬碟IO開銷很大, 會成為系統效能瓶頸, 因此MySQL針對這部分做了優化. <br> <br>
ps. 當從硬碟讀取資料時會將周遭的資料也一起讀入記憶體內, 而不是單單只有當前硬碟地址地資料 (局部預讀性原理), <br>
當電腦訪問硬碟上某位址時其附近區域的資料很快也會被讀取到. 每次硬碟IO都會讀取一頁 (page, 多大取決於作業系統, 一般是4k or 8k). <br> <br>


索引之所以會加快硬碟訪問速度其根本原因就在於減少了訪問硬碟IO次數, 下面簡單講一下B Tree And B+ Tree <br>
B-Tree簡略示意圖 (借用一下網路上的圖) <br>
![](./img/B-Tree.png)
特點:
1. 樹內每個節點都儲存資料
2. 樹葉間無指針連結
3. 是一個平衡樹
<br>
   
B+ - Tree簡略示意圖
![](./img/B+%20Tree.png)
特點:
1. 只有葉節點儲存資料
2. 葉節點之間互有指針連接

MySQL InnoDB 預設索引引擎為B+ Tree Why?
1. B+樹透過葉節點訪問可有效率的做到範圍查詢, 減少IO次數
<br>
   
* Clustered Index (叢集索引) And Secondary Index (非叢集索引) <br>
Clustered Index: 資料庫資料存放數據與index順序相同, 表的物理順序只可能有一種, 所以叢集索引只會有一個 (primary key, 更快的執行速度). <br>
1. 在InnoDB中, 叢集索引默認就是Primary Key
2. 如果表中沒有定義PK, 則該表中第一個唯一非空索引被作為叢集索引
3. 如果沒有PK也沒有唯一索引則InnoDB內部會生成隱藏主鍵作為叢集索引(6 byte的字增列)
ps. pk是uuid而非自增就會產生一個問題, 因為如果是自增的資料一定是放在相鄰的硬碟上的, 寫入性能佳, uuid因為具有隨機性, 會導致隨機io, 寫入效能差. <br>
   
假設有下表 (id為pk, name為一般index)
![](./img/index_s_1.png)
當執行 ```SELECT name FROM student WHERE id=2;``` 時, 查詢過程如下
![](./img/index_s_2.png)
1. 先找到樹根所在硬碟區塊, 讀入記憶體 (第一次Disk IO) (其實InnoDB會將樹根常駐記憶體)
2. 在記憶體中判斷id=3鎖在區間 (1,8), 找到區間對應指針 (第一次記憶體查找)
3. 根據指針1紀錄的硬碟位置找到硬碟區塊2讀入內存 (第二次Disk IO)
4. 在記憶體中判斷id=3所在區間(2,4), 找到對應指針 (第二次記憶體查找)
5. 根據指針2紀錄的硬碟位置找到硬碟區塊4讀入內存 (第三次Disk IO)
6. 在記憶體找到id=2的對應資料 (第三次記憶體查找)

Secondary Index: 如下圖, 多加一個索引就多生成一顆非叢集索引樹, 新增資料時同時需要維持這幾棵樹的變化. <br>
非叢集索引樹葉上已不是真實資料而是索引自身值與主鍵索引值.   
![](./img/index_s_3.png)
當執行下面SQL時
```text
SELECT id,name FROM student WHERE name='叶良辰';
```
查詢過程跟叢集索引一樣, 只需要掃描一次樹, 就可以拿到想要的資料, 但如果下面的SQL情況就不同了 (score非index)
```text
SELECT score FROM student WHERE name='叶良辰';
```
![](./img/index_s_4.png)
因走訪完樹後只能得到id,name, 所以利用id再去叢集索引查詢score, 需要兩段這個過程稱為**回表** <br>

(待補)
